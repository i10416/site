# Hindley-Milner Type Inference

## Hindley-Milner 型推論

1960年くらいに発案された型推論の理論. この HM型推論を拡張したものがいわゆる ML 系言語の型推論として使われている. 未知の型でも型の木構造を潜っていくとプリミティブな型に行きつくので、そこから型の連立方程式を解くことで与えられたの式の型を再帰的に推論できる.

### 型推論とは

型推論は 型環境（変数の名前から、その型への写像）envと、式 expr とを受け取り、expr の型を推論して返すような関数である.

なお、これは記号を用いて Env ⊢  expr : InferedType とも書ける(a⊢b はaという仮定の下でbが証明される、というニュアンス).

例: `expr = Add(t0,t1)` なら `env.lookup(t0)`で `Int` と推論された型 `T0'` を得る. `T0'` を `unify` 関数にかけることで `T0'` が `Int` であることを確認する.



以下は [min-caml の資料](http://esumii.github.io/min-caml/tutorial-mincaml-8.htm)から.

※ ただし原文の min-caml 特有の記述を一部削ったり、一部の表現を変えてたりしている.

> 型推論を行う関数(以下 `g` とする.)は、型環境（変数の名前から、その型への写像）`env` と、式 `expr` とを受け取り、`expr` の型を推論して返します(`g := env => expr => InferedType`). また、式の中に出てくる変数の型が合っているかどうかも調べます. もし未定義の型変数があったら、適切な型を代入します. このような代入により型を合わせる関数が `unify` です.

> たとえば、`Add(e1, e2)` だったら、まず`g env e1`により部分式 `e1` の型を推論し、その型が `int` であることを `unify` により確かめます。部分式 `e2` についても同様です。そして、式全体の型として `int` を返します。

> 少しややこしい例としては、関数適用 `e e1 ... en` があります. `e`が関数で、`e1` から `en` までが引数です. この場合は、関数の型は `g env e`、引数の型は `g env e1, ..., g env en` のように推論できますが、返値の型がわかりません。そこで、未定義の新しい型変数 `t`を作り、`g env e` が「`g env e1, ..., g env en` を受け取って `t` を返す」関数型と等しくなるように `unify` を呼んでいます。そして、式全体の型として`t` を返します.


> `let` や `let rec` のように新しい変数が導入されるところでは、型環境 `env` が拡張されます. 逆に変数 `x` が出てきたら、型環境 `env` を引いて型を得ます.

> 関数 `unify` は、与えられた二つの型が等しいかどうかを中まで調べていき、一方が未定義の型変数だったら、他方と等しくなるように代入を行います. ただし一方の型変数が、他方の型の中に現れていないかどうかチェックします（occur checkと呼ばれます）.もし現れていると、代入結果の型にサイクルができてしまうからです。たとえば、もし（occur checkをしないで）型変数`α`と関数型`int→α` を `unify` してしまうと、`α = int→α` なので、`int→int→int→...` という無限長の型になってしまいます！　このようなことを防止するために（ちょっとややこしいですが）occur checkは必要なのです.

 
### 型環境とは

先のセクションでは特に説明もなく(型)環境 `Env` という言葉を出したが、これは出現した変数の型についての仮定をあつめたものである.

> 一般に式には変数が現れるため，例えば単に x が int を持つか，といわれても判断することができない．このため，変数に対しては，そ れが持つ型を何か仮定しないと型判断は下せないことになる．この，変数に 対して仮定する型に関する情報を型環境(type environment)(メタ変 数Γ)と呼び，変数から型への部分関数で表される https://www.fos.kuis.kyoto-u.ac.jp/~igarashi/class/isle4-06w/text/miniml011.html

### unify

`unify(t0,t1)` は `t0 == t1` を満たすような型の置換 Subst を返す関数.

例: `t0 := a`, `t1 := b => c` なら `a == b => c`となるような置換 `S` を返す.

## 余談

参考実装を見ながらなぞるのはできるが型の理論を完全に理解するにはまだまだ先が長い...(´･ω･｀)

https://github.com/i10416/naivetypeinference に実装は置いてある.

しかし情報系の学習は優良な資料がネットに無料で転がってるからとても助かる🦝スカスカのスライドじゃなくて文書とコードのまとまったウェブサイトなのでなおさらうれしい. 経済学徒もそうしてくれ🙄
